# payments/views.py - TO'LIQ TUZATILGAN (Payme response format fixed)
import base64
import json
import logging
from decimal import Decimal
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.utils import timezone
from django.db import transaction as db_transaction
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.conf import settings
from .models import BotUser, Payment, PricingTariff, PricingHistory
from .payme_utils import create_payme_link, check_payme_auth, tiyin_to_sum, sum_to_tiyin
from django.db import models
logger = logging.getLogger(__name__)


# ============= BOT UCHUN API ENDPOINTLAR =============

@api_view(['GET'])
def get_tariffs(request):
    """Barcha faol tariflarni olish"""
    try:
        tariffs = PricingTariff.objects.filter(is_active=True).order_by('count')
        data = []
        for t in tariffs:
            price_per_one = float(t.price_per_one) if hasattr(t, 'price_per_one') else float(t.price) / t.count
            data.append({
                'id': t.id,
                'name': t.name,
                'count': t.count,
                'price': float(t.price),
                'price_per_one': price_per_one
            })
        return Response({'success': True, 'tariffs': data})
    except Exception as e:
        logger.error(f"Get tariffs error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def create_user(request):
    """Foydalanuvchi yaratish yoki yangilash"""
    telegram_id = request.data.get('telegram_id')
    full_name = request.data.get('full_name', '')
    username = request.data.get('username', '')

    if not telegram_id:
        return Response({'success': False, 'error': 'telegram_id majburiy'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user, created = BotUser.objects.get_or_create(
            telegram_id=telegram_id,
            defaults={'full_name': full_name, 'username': username}
        )

        if not created:
            # Mavjud userni yangilash
            if full_name:
                user.full_name = full_name
            if username is not None:
                user.username = username
            user.save()

        return Response({
            'success': True,
            'telegram_id': user.telegram_id,
            'balance': user.balance,
            'full_name': user.full_name,
            'username': user.username,
            'phone': user.phone,  # ‚úÖ PHONE field
            'is_active': user.is_active,
            'created': created
        })
    except Exception as e:
        logger.error(f"Create user error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def update_phone(request):
    """Telefon raqamini yangilash"""
    telegram_id = request.data.get('telegram_id')
    phone = request.data.get('phone')

    if not telegram_id or not phone:
        return Response({
            'success': False,
            'error': 'telegram_id va phone majburiy'
        }, status=status.HTTP_400_BAD_REQUEST)

    try:
        user = BotUser.objects.get(telegram_id=telegram_id)
        user.phone = phone
        user.save(update_fields=['phone', 'updated_at'])

        logger.info(f"‚úÖ Phone updated: {telegram_id} -> {phone}")

        return Response({
            'success': True,
            'telegram_id': user.telegram_id,
            'phone': user.phone,
            'message': 'Telefon raqami yangilandi'
        })
    except BotUser.DoesNotExist:
        return Response({
            'success': False,
            'error': 'Foydalanuvchi topilmadi'
        }, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        logger.error(f"Update phone error: {e}", exc_info=True)
        return Response({
            'success': False,
            'error': str(e)
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
def get_balance(request, telegram_id):
    """Foydalanuvchi balansini olish"""
    try:
        user = BotUser.objects.get(telegram_id=telegram_id)
        return Response({
            'success': True,
            'telegram_id': user.telegram_id,
            'balance': user.balance,
            'full_name': user.full_name,
            'username': user.username
        })
    except BotUser.DoesNotExist:
        return Response({'success': False, 'error': 'Foydalanuvchi topilmadi'}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        logger.error(f"Get balance error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def use_pricing(request):
    """Narxlashdan foydalanish (balansni kamaytirish)"""
    telegram_id = request.data.get('telegram_id')
    phone_model = request.data.get('phone_model', '')
    price = request.data.get('price', 0)

    if not telegram_id:
        return Response({'success': False, 'error': 'telegram_id majburiy'}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user = BotUser.objects.get(telegram_id=telegram_id)

        if user.balance <= 0:
            return Response({'success': False, 'error': 'Balans yetarli emas', 'balance': 0},
                            status=status.HTTP_400_BAD_REQUEST)

        with db_transaction.atomic():
            user.balance -= 1
            user.save()
            PricingHistory.objects.create(user=user, phone_model=phone_model, price=price)

        return Response({'success': True, 'balance': user.balance, 'message': 'Narxlash muvaffaqiyatli'})
    except BotUser.DoesNotExist:
        return Response({'success': False, 'error': 'Foydalanuvchi topilmadi'}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        logger.error(f"Use pricing error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['POST'])
def create_payment(request):
    """To'lov havolasini yaratish (tarif asosida)"""
    telegram_id = request.data.get('telegram_id')
    tariff_id = request.data.get('tariff_id')

    if not telegram_id or not tariff_id:
        return Response({'success': False, 'error': 'telegram_id va tariff_id majburiy'},
                        status=status.HTTP_400_BAD_REQUEST)

    try:
        user = BotUser.objects.get(telegram_id=telegram_id)
        tariff = PricingTariff.objects.get(id=tariff_id, is_active=True)

        payment = Payment.objects.create(
            user=user,
            tariff=tariff,
            amount=tariff.price,
            pricing_count=tariff.count,
            state=Payment.STATE_CREATED
        )

        logger.info(
            f"‚úÖ Payment created: #{payment.id} (order_id: {payment.order_id}), user: {telegram_id}, tariff: {tariff.name}")

        # ‚úÖ FAQAT order_id va amount yuboriladi
        payme_url = create_payme_link(
            order_id=str(payment.order_id),
            amount=float(tariff.price)
        )

        if not payme_url:
            logger.error(f"‚ùå Failed to create Payme URL for payment #{payment.id}")
            return Response({'success': False, 'error': 'Payme havolasini yaratishda xatolik'},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        logger.info(f"‚úÖ Payme URL created: {payme_url}")

        return Response({
            'success': True,
            'payment_id': payment.id,
            'order_id': str(payment.order_id),
            'payment_url': payme_url,
            'amount': float(tariff.price),
            'count': tariff.count,
            'tariff_name': tariff.name
        })
    except BotUser.DoesNotExist:
        return Response({'success': False, 'error': 'Foydalanuvchi topilmadi'}, status=status.HTTP_404_NOT_FOUND)
    except PricingTariff.DoesNotExist:
        return Response({'success': False, 'error': 'Tarif topilmadi yoki faol emas'}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        logger.error(f"‚ùå Create payment error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ============= PAYME CALLBACK =============

logger = logging.getLogger("payme")


@csrf_exempt
@require_http_methods(["POST"])
def payme_callback(request):
    """
    Payme Merchant API callback handler
    ‚ö†Ô∏è Payme talabiga ko‚Äòra HAR DOIM HTTP 200
    """
    request_id = None

    try:
        # ==============================
        # 0. RAW DEBUG
        # ==============================
        raw_auth = request.META.get("HTTP_AUTHORIZATION", "")
        raw_body = request.body.decode("utf-8", errors="ignore")

        logger.warning("===== PAYME RAW REQUEST =====")
        logger.warning(f"AUTH HEADER: {raw_auth}")
        logger.warning(f"RAW BODY: {raw_body}")
        logger.warning("=============================")

        # ==============================
        # 1. JSON PARSE
        # ==============================
        try:
            body = json.loads(raw_body)
        except json.JSONDecodeError:
            return JsonResponse({
                "jsonrpc": "2.0",
                "error": {"code": -32700, "message": "Parse error"},
                "id": None
            }, status=200)

        method = body.get("method")
        params = body.get("params") or {}
        request_id = body.get("id")

        logger.info(f"üì• Payme METHOD: {method}")
        logger.info(f"üì• Payme PARAMS: {params}")

        # ==============================
        # 2. AUTH CHECK (YAGONA MANBA)
        # ==============================
        if not check_payme_auth(request):
            return JsonResponse({
                "jsonrpc": "2.0",
                "error": {
                    "code": -32504,
                    "message": "Insufficient privileges"
                },
                "id": request_id
            }, status=200)

        # ==============================
        # 3. METHOD ROUTING
        # ==============================
        if method == "CheckPerformTransaction":
            result = check_perform_transaction(params)

        elif method == "CreateTransaction":
            result = create_transaction(params)

        elif method == "PerformTransaction":
            result = perform_transaction(params)

        elif method == "CancelTransaction":
            result = cancel_transaction(params)

        elif method == "CheckTransaction":
            result = check_transaction(params)

        elif method == "GetStatement":
            result = get_statement(params)

        elif method == "ChangePassword":
            result = change_password(params)

        else:
            return JsonResponse({
                "jsonrpc": "2.0",
                "error": {"code": -32601, "message": "Method not found"},
                "id": request_id
            }, status=200)

        # ==============================
        # 4. FINAL RESPONSE
        # ==============================
        if "error" in result:
            return JsonResponse({
                "jsonrpc": "2.0",
                "error": result["error"],
                "id": request_id
            }, status=200)

        return JsonResponse({
            "jsonrpc": "2.0",
            "result": result,
            "id": request_id
        }, status=200)

    except Exception:
        logger.exception("‚ùå PAYME CALLBACK FATAL ERROR")
        return JsonResponse({
            "jsonrpc": "2.0",
            "error": {"code": -32400, "message": "Internal error"},
            "id": request_id
        }, status=200)


def check_perform_transaction(params):
    """
    CheckPerformTransaction - To'lov ruxsatini tekshirish.
    Payme tranzaksiya yaratishdan oldin summani va buyurtmani tekshiradi.
    """
    account = params.get("account", {})
    order_id = account.get("order_id")
    amount_tiyin = params.get("amount")

    if not order_id:
        return {"error": {"code": -31050, "message": "Order ID not specified"}}

    try:
        payment = Payment.objects.get(order_id=order_id)

        # 1. Summani tekshirish (Tiyin vs So'm)
        if sum_to_tiyin(payment.amount) != int(amount_tiyin):
            return {"error": {"code": -31001, "message": "Incorrect amount"}}

        # 2. To'lov holatini tekshirish (Faqat 'Yaratildi' holatida bo'lishi kerak)
        if payment.state != Payment.STATE_CREATED:
            return {"error": {"code": -31099, "message": "Order is not available for payment"}}

        return {"allow": True}

    except Payment.DoesNotExist:
        return {"error": {"code": -31050, "message": "Order not found"}}


def create_transaction(params):
    """
    CreateTransaction - Tranzaksiyani yaratish yoki mavjudini qaytarish.
    Idempotentlik: Agar bir xil tranzaksiya ID kelsa, yangi yaratmaymiz, borini qaytaramiz.
    """
    transaction_id = params.get("id")
    transaction_time = params.get("time")
    amount_tiyin = params.get("amount")
    account = params.get("account", {})
    order_id = account.get("order_id")

    # 1. Tranzaksiyani ID bo'yicha qidirish (Idempotency check)
    existing_tx = Payment.objects.filter(payme_transaction_id=transaction_id).first()
    if existing_tx:
        return {
            "create_time": existing_tx.payme_create_time,
            "perform_time": int(existing_tx.performed_at.timestamp() * 1000) if existing_tx.performed_at else 0,
            "cancel_time": int(existing_tx.cancelled_at.timestamp() * 1000) if existing_tx.cancelled_at else 0,
            "transaction": existing_tx.payme_transaction_id,
            "state": existing_tx.state,
            "reason": existing_tx.reason
        }

    # 2. Buyurtmani tekshirish
    try:
        payment = Payment.objects.get(order_id=order_id)
    except Payment.DoesNotExist:
        return {"error": {"code": -31050, "message": "Order not found"}}

    # 3. Buyurtma allaqachon boshqa tranzaksiya bilan bandmi?
    if payment.payme_transaction_id and payment.payme_transaction_id != transaction_id:
        return {"error": {"code": -31099, "message": "Order has another transaction"}}

    # 4. Summa mosligini tekshirish
    if sum_to_tiyin(payment.amount) != int(amount_tiyin):
        return {"error": {"code": -31001, "message": "Incorrect amount"}}

    # 5. Hammasi to'g'ri bo'lsa, tranzaksiya ma'lumotlarini saqlaymiz
    payment.payme_transaction_id = transaction_id
    payment.payme_create_time = transaction_time
    payment.state = Payment.STATE_CREATED
    payment.save()

    return {
        "create_time": payment.payme_create_time,
        "perform_time": 0,
        "cancel_time": 0,
        "transaction": payment.payme_transaction_id,
        "state": payment.state,
        "reason": None
    }


def perform_transaction(params):
    """
    PerformTransaction - To'lovni tasdiqlash va foydalanuvchi balansiga qo'shish.
    """
    payme_id = params.get('id')

    try:
        payment = Payment.objects.get(payme_transaction_id=payme_id)

        # Tranzaksiya holati 'Yaratildi' bo'lsa, uni 'To'landi' holatiga o'tkazamiz
        if payment.state == Payment.STATE_CREATED:
            with db_transaction.atomic():
                payment.state = Payment.STATE_COMPLETED
                payment.performed_at = timezone.now()
                payment.save()

                # Foydalanuvchi balansini oshirish
                user = payment.user
                user.balance += payment.pricing_count
                user.save()

            return {
                "transaction": payment.payme_transaction_id,
                "perform_time": int(payment.performed_at.timestamp() * 1000),
                "state": payment.state
            }

        # Agar allaqachon to'langan bo'lsa (Idempotent response)
        elif payment.state == Payment.STATE_COMPLETED:
            return {
                "transaction": payment.payme_transaction_id,
                "perform_time": int(payment.performed_at.timestamp() * 1000),
                "state": payment.state
            }

        else:
            return {"error": {"code": -31008, "message": "Cannot perform transaction"}}

    except Payment.DoesNotExist:
        return {"error": {"code": -31003, "message": "Transaction not found"}}


def cancel_transaction(params):
    """
    CancelTransaction - Tranzaksiyani bekor qilish.
    """
    payme_id = params.get('id')
    reason = params.get('reason')

    try:
        payment = Payment.objects.get(payme_transaction_id=payme_id)

        # 1. Allaqachon bekor qilingan bo'lsa (Idempotent)
        if payment.state in [Payment.STATE_CANCELLED, Payment.STATE_CANCELLED_AFTER_COMPLETE]:
            return {
                "transaction": payment.payme_transaction_id,
                "cancel_time": int(payment.cancelled_at.timestamp() * 1000),
                "state": payment.state
            }

        # 2. Bekor qilish mantiqi
        if payment.state == Payment.STATE_CREATED:
            payment.state = Payment.STATE_CANCELLED
        elif payment.state == Payment.STATE_COMPLETED:
            # To'lov bajarilgandan keyin bekor bo'lsa, balansdan ayiramiz
            payment.state = Payment.STATE_CANCELLED_AFTER_COMPLETE
            if payment.user.balance >= payment.pricing_count:
                payment.user.balance -= payment.pricing_count
                payment.user.save()

        payment.cancelled_at = timezone.now()
        payment.reason = reason
        payment.save()

        return {
            "transaction": payment.payme_transaction_id,
            "cancel_time": int(payment.cancelled_at.timestamp() * 1000),
            "state": payment.state
        }

    except Payment.DoesNotExist:
        return {"error": {"code": -31003, "message": "Transaction not found"}}


def check_transaction(params):
    """
    CheckTransaction - Tranzaksiya holatini tekshirish.
    """
    payme_id = params.get("id")

    try:
        payment = Payment.objects.get(payme_transaction_id=payme_id)

        return {
            "create_time": payment.payme_create_time or 0,
            "perform_time": int(payment.performed_at.timestamp() * 1000) if payment.performed_at else 0,
            "cancel_time": int(payment.cancelled_at.timestamp() * 1000) if payment.cancelled_at else 0,
            "transaction": payment.payme_transaction_id,
            "state": payment.state,
            "reason": payment.reason
        }
    except Payment.DoesNotExist:
        return {"error": {"code": -31003, "message": "Transaction not found"}}


def get_statement(params):
    """GetStatement - To'lovlar hisoboti"""
    try:
        from_time = params.get('from')
        to_time = params.get('to')

        logger.info(f"üìä GetStatement: from={from_time}, to={to_time}")

        from_datetime = timezone.datetime.fromtimestamp(from_time / 1000)
        to_datetime = timezone.datetime.fromtimestamp(to_time / 1000)

        payments = Payment.objects.filter(
            created_at__gte=from_datetime,
            created_at__lte=to_datetime,
            payme_transaction_id__isnull=False
        )

        transactions = []
        for payment in payments:
            transactions.append({
                'id': payment.payme_transaction_id,
                'time': int(payment.created_at.timestamp() * 1000),
                'amount': sum_to_tiyin(payment.amount),
                'account': {'order_id': str(payment.order_id), 'telegram_id': payment.user.telegram_id},
                'create_time': int(payment.created_at.timestamp() * 1000),
                'perform_time': int(payment.performed_at.timestamp() * 1000) if payment.performed_at else 0,
                'cancel_time': int(payment.cancelled_at.timestamp() * 1000) if payment.cancelled_at else 0,
                'transaction': str(payment.id),
                'state': payment.state,
                'reason': payment.reason
            })

        return {'transactions': transactions}

    except Exception as e:
        logger.error(f"‚ùå GetStatement error: {e}", exc_info=True)
        return {'error': {'code': -32400, 'message': str(e)[:100]}}


def change_password(params):
    global PAYME_RUNTIME_SECRET

    try:
        new_password = params.get("password")
        if not new_password:
            return {
                "error": {
                    "code": -32602,
                    "message": "Invalid params"
                }
            }

        # üîê yangi parolni eslab qolamiz (sandbox)
        PAYME_RUNTIME_SECRET = new_password

        logger.info("üîê Payme password changed successfully (sandbox)")
        return True   # MUHIM!

    except Exception as e:
        return {
            "error": {
                "code": -32400,
                "message": str(e)[:100]
            }
        }



# ============= STATUS ENDPOINTS =============

@api_view(['GET'])
def check_last_payment_status(request, telegram_id):
    """Oxirgi to'lov holatini tekshirish (5 daqiqa)"""
    try:
        user = BotUser.objects.get(telegram_id=telegram_id)
        time_threshold = timezone.now() - timezone.timedelta(minutes=5)
        payment = Payment.objects.filter(user=user, created_at__gte=time_threshold).order_by('-created_at').first()

        if not payment:
            return Response({'success': False, 'error': 'Yaqinda to\'lov topilmadi', 'has_payment': False})

        return Response({
            'success': True,
            'payment_id': payment.id,
            'state': payment.state,
            'state_display': payment.get_state_display(),
            'amount': float(payment.amount),
            'count': payment.pricing_count,
            'balance': user.balance,
            'has_payment': True
        })
    except BotUser.DoesNotExist:
        return Response({'success': False, 'error': 'Foydalanuvchi topilmadi'}, status=404)
    except Exception as e:
        logger.error(f"Check last payment status error: {e}")
        return Response({'success': False, 'error': str(e)}, status=500)


@api_view(['GET'])
def check_payment_status(request, order_id):
    """To'lov holatini tekshirish ORDER_ID orqali"""
    try:
        payment = Payment.objects.filter(order_id=order_id).first()

        if not payment:
            return Response({'success': False, 'error': 'Payment not found', 'has_payment': False},
                            status=status.HTTP_404_NOT_FOUND)

        user = payment.user

        return Response({
            'success': True,
            'has_payment': True,
            'payment_id': payment.id,
            'order_id': str(payment.order_id),
            'state': payment.state,
            'state_display': payment.get_state_display(),
            'amount': float(payment.amount),
            'count': payment.pricing_count,
            'balance': user.balance,
            'created_at': payment.created_at.isoformat(),
            'performed_at': payment.performed_at.isoformat() if payment.performed_at else None,
            'cancelled_at': payment.cancelled_at.isoformat() if payment.cancelled_at else None,
            'tariff_name': payment.tariff.name if payment.tariff else None,
            'payme_transaction_id': payment.payme_transaction_id or None
        })

    except Exception as e:
        logger.error(f"Check payment status error: {e}", exc_info=True)
        return Response({'success': False, 'error': str(e), 'has_payment': False},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR)

